{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/07/31/hello-world/"},{"title":"【C++ Primer】学习笔记1","text":"[C++ Primer]学习笔记11.C++中的输入与输出C++语言未定义任何输入与输出(IO)的语句，而包含了一个标准库来提供IO机制。大部分示例使用的是iostream这个标准库，其包含了4个IO对象。其中有：(1)istream—-cin(输入)(2)ostream—-cout(输出)(3)ostream—-cerr(输出错误和警告信息)(4)ostream—-clog(输出程序运行时的一般信息)值得注意的是，istream和ostream分别表示输入输出流（一个字符序列）。这个流的写入使用&gt;&gt;(输入运算符)，输出用&lt;&lt;(输出运算符)。而这两个运算符在使用时，左边都需要是一个ostream/istream对象，右边都需要是要输入或输出的值。例如说：std::cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; endl;std::cin &gt;&gt; a1;输出与输入运算符相似的地方在于：他们都是以左边为左侧运算对象，再接受一个对象作为其右侧运算对象。二者返回其左侧运算对象作为其计算结果(如cout &lt;&lt; &quot;Hello,world!&quot;返回的是一个ostream，因此可以继续运算)。再举一个例子就容易理解：cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; &quot;hello&quot; &lt;&lt; ...我们可以一直在其右侧继续运算，因为左侧一直都是一个ostream对象。同时还需要注意的是endl这个操纵符，它的作用是结束当前行，并将与设备关联的缓冲区的内容刷到设备中（其实就是保证之前的cout准确的输出出去，不要停留在缓冲区中）。 2.注释需要注意的地方注释有两种：(1)单行注释//(2)注释界定符/* /*，以/*开始，以*/结束。需要注意的是注释界定符不能嵌套。举个例子：cout &lt;&lt; /* &quot;*/&quot; */ 其等同于 cout &lt;&lt; &quot; */，因为其中的部分内容被注释掉了。 3.控制流(for与while)仅记录值得注意的点：(1) while(i++){}，i在进入while之后，就会++，而不是执行完整个while。(2)for(int i=n(正整数);i&lt;=0;i--)，这种语句没有尽头，会一直执行，在写for的时候初始化需要注意。(3)while与for的优缺点：for循环语句的控制变量初始化和修改在句首，简洁直观，适用于循环次数已知的情况，而while语句的控制变量初始化通常在循环结构体外，修改在循环结构体内，适用于未知循环次数的情况。 4.C++语言的数据类型问题C++是一种静态数据类型语言，它的类型检查发生在编译的时候，因此编译器必须知道每个变量对应的数据类型，而python这类语言是动态的，在程序运行时检查数据类型。 5.C++的基本内置类型C++定义了一套算数类型和空类型。算数类型包括2类：整形(包括字符和布尔类型)和浮点型。下表记列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位(机器字节） short 短整形 16位 int 整形 16位 long 长整形 32位 long long 长整形 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 C++语言规定short&lt;=int&lt;=long&lt;=long long；float-32bit，double-64bit。 选择数据类型的准则：(1)明确知晓数据不可能为负数时，选用无符号类型。(2)进行整数运算时，要么选int，要么选long long。一般short太小，long和int有一样的尺寸，所以用long long。(3)进行浮点运算时尽量选用double，因为float通常精度不够，并且二者的计算代价相差不多。 类型转换的一些注意事项unsigned char c = -1;，当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。此句中c = -1%256 = -1+256 = 255;signed char c2 = 256;,当我们赋给一个有符号类型一个超出它表示范围的值时，结果是未定义的。 123unsigned u =10;int i = -42;cout &lt;&lt; u+i &lt;&lt; endl; //如果int占32位，那么输出4294968264 解释：当一个算数表达式中既有int和无符号数时，会将int转化为无符号数。把负数转化为无符号数类似于直接给无符号数赋予一个负值，结果等于: -42+2^32。 6.字面值常量如cin &lt;&lt; 42; 42就是一个字面值常量。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。整形和浮点型字面值整形字面值可写作十进制、八进制、十六进制。例如我们可以以下列方式表示数值20：(1) 20 (2)024 (3)0x14整形字面值的具体数据类型由其值与符号决定。默认情况下十进制字面值是带符号数，其他二者既可能是带符号数也可能是无符号数。十进制在int、long、long long中选择能容下其数值的最小数据类型。而十六进制在unsigned int … unsign long long(6种)中选择最小尺寸的。奇怪的规定：如果我们选用-42，整形字面值仍然是42，负号仅仅在存储在有符号数中取反。浮点字面值表现为一个小数或以科学计数法表示的指数：(1)3.14159 (2)3.14159E0 (3)0. (4)0e0 (5)0.001浮点型字面值默认是double型。字符与字符串字面值由单引号' '括起来的一个字符被称为char型字面值，由双引号&quot; &quot;括起来的是零个或多个字符构成字符串字面值。'a' //字符型字面值&quot;Hello world！&quot; //字符串型字面值 7.指定字面值的类型通过添加一些前缀和后缀，可以改变整形、浮点型和字符型的默认类型。字符和字符串 前缀 含义 类型 u Unicode 16字符 char16_t U Unicode 32字符 char32_t L 宽字符 wchar_t u8 UTF-8(仅用于字符串字面常量) 整形字面值 后缀 最小匹配类型 u or U unsigned l or L long ll or LL long long 浮点型字面值 后缀 类型 f or F float l or L long double 对于一个整形变量，如果后缀带U，那么它就会在三种unsigned中选择尺寸最小的，如果后缀带L，那么至少会是long，如果后缀带LL，那么将会是long long或者unsigned long long的一种。值得注意的是L和U可以组合使用。 8.变量一些值得注意的点与定义：(1)对象：指一块能储存数据并具有某种类型的内存空间。(2) 初始化与赋值是两个完全不同的操作。(3) 变量定义的基本形式：类型说明符+一个或多个变量组成的列表，变量名以逗号分隔，以分号结束。(4) 用花括号初始化变量时，若初始值存在信息丢失风险，则编译会报错。如下面的代码所示: 123456int a = 0; //正确 int b = {0} //正确int c{0};//正确 int d(0); //正确 int e = 3.14 //正确，a=3int f = {3.14} //报错，因为3.14转化为int后会丢失信息 (5) 一个函数在定义时没有指定初值，那么在函数体外则会初始化为0，在函数体内为未定义，访问则会报错。(6) C++支持分离式编译，声明使得名字为程序所知，而定义负责创建与名字关联的实体。即：声明仅规定变量类型与名称，而定义还会申请储存空间。(7) 作用域是程序的一部分，一个花括号就是一个作用域。在作用域内定义变量是局部的。而在花括号以外定义的变量与函数则是全局的。main也是一个函数。(8) 复合类型：复合类型是指基于其他类型定义的类型。如引用和指针。(9)引用：其本质就是起别名，为原有的对象起了另外一个名，引用必须初始化。(即与对象绑定，绑定后不可更改绑定对象)引用仅仅是别名，不是对象，因此不能定义引用的引用。 12int ival = 1024;int &amp;refVal = ival; (10) 指针：指针是对象，有其自己的地址。这点与引用不同，同时，指针无需在定义的时候赋初值。指针存放着指向对象的地址，若我们想要访问这个对象，则需要用到解引用符*。为了给指针赋予对象的地址，我们需要用到取址符&amp;。 123double dval = 2.0;double *pd = &amp;dval;cout &lt;&lt; &quot;dval = &quot; &lt;&lt; *pd &lt;&lt; endl; (11)空指针：生成空指针的方式有三种： 123int *p1 = nullptr; int *p2 = 0; int *p3 = NULL; 其中nullptr是C++11引入，推荐使用。而NULL是预处理变量，在编译时候替换成0值。(12)void*指针：它可以存放任何类型数据的地址，但不能直接通过它操作对象。(13)遇到较为复杂的定义时候，推荐从右往左理解定义。 9.const限定符产生原因：我们想要定义一个变量，它的值在程序运行过程中不能改变，仅仅在程序开头定义时候可改变。如缓冲区大小const int rxbuff = 100;。因为const对象一旦创建就不可更改，因此必须初始化。初始化时，右边输入的值是否是const都无所谓。引用的类型必须与其所引用对象的类型一致，但有两个例外：(1) 初始化常量引用时允许用任意表达式作为初始值。只要该表达式能够转化成引用的类型。(2) 允许一个常量引用绑定非常量的对象、字面值，甚至是一般表达式。第一个例子：const int r1 去绑定一个变量(int)i，并且能够随着i的值而变化。 12345678int i = 42;const int &amp;r1 = i;cout &lt;&lt; &quot;r1 = &quot; &lt;&lt; r1 &lt;&lt; endl;i = 40;cout &lt;&lt; &quot;r1 = &quot; &lt;&lt; r1 &lt;&lt; endl;output: r1 = 42;r1 = 40; 第二个例子：const int r1 去绑定一个变量(double)i，但是不能随着i值变化。 12345678double i = 42.222;const int &amp;r1 = i;cout &lt;&lt; &quot; r1 = &quot; &lt;&lt; r1 &lt;&lt; endl;i = 3.141;cout &lt;&lt; &quot; r1 = &quot; &lt;&lt; r1 &lt;&lt; endl;output:r1 = 42;r1 = 42; 这是怎么回事呢？让我们看下原理，在编译器将上述代码变成了怎样： 12const int temp = i;const int &amp;r1 = temp; 即：r1绑定的是一个临时定义的const int值，因此在i值变化时，通过r1访问，值不会发生变化。而在执行第一句时候，编译器将i(double)赋给temp(int)时也舍去了小数点后的数据。不管是r1(const int &amp;)是绑定一个int还是绑定一个double，我们都不能通过r1去改变其值。但其值可以由其他方式修改。 指针与const指针常量与const一样，指针也可以指向常量与非常量，如果想要指向常量的指针，我们的指针也必须定义为常量指针。 1234const double pi = 3.14;double *p1 = &amp;pi; //错误，因为类型不符合。const double *p2 = &amp;pi; //正确 *p2 = 3.1415926; //错误，常量指针不能通过指针去修改其指向的对象。 与const一样，指针在定义的时候必须与指向对象的数据类型一致，但也有例外：允许令一个常量指针指向一个非常量的对象:double dval = 3.14;const double * cptr = &amp;dval;上述代码也是能正常运行的。常量指针将指针定义为一个常量(即它只能指向初始化时的对象，不能更改) int num = 0;int const *p = &amp;num; //p一直指向numint a = 1;p = &amp;a;//错误，因为不可更改其指向对象 值得注意的是：常量指针不可通过指针修改对象，但指针常量可以。注意二者的区别。 10.顶层const与底层const顶层const：指针本身是一个常量(指针常量)底层const：指针指向的是一个常量(常量指针)对于一个算数类型、类，顶层const则是指自己。 11.constexpr(C++11新特性)与常量表达式常量表达式是指值不会改变并且在编译过程就能得到结果的表达式。字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。一个对象是不是常量表达式由其数据类型和初始值决定。 const int max_files = 20;//max_files是常量表达式const int limit = max_files + 1; //limit是常量表达式int a = 25; //a不是常量表达式const int sz = s.size(); // sz也不是常量表达式，其值只有运行了size后才能确定。 constexpr引出原因：在复杂的系统中，我们根本无法确定右边的值到底是不是常量，因此我们用constexpr去定义一个变量的时候，就能依靠编译器知道我们是否定义出了一个常量。 constexpr int mf = 20;//正确constexpr int limit = mf+1; //正确constexpr int sz = s.size(); //错误，其值运行size后才知道，或者我们能够将size函数变成一个constexpr函数，此时就能编译通过。 字面值类型constexpr在编译时就能得出结果，因此用他所定义的对象不能太过复杂，这些类型比较简单得到，我们就称之为字面值类型，如算数类型、引用、指针都属于字面值类型。而自定义数据类型、IO库、string类就不能定义constexpr类型。 指针与constexpr用constexpr定义的指针一定为指针常量，即不能更改对象。 12.处理类型随着程序越来越复杂， 类型也会变得越来越复杂，我们通常会像引用那样给想要定义的数据类型其别名，这就需要用到类型别名，有两种方法定义：1.使用typedef关键字2.使用别名声明using typedef double wages;wages pi = 3.14;//等同于 double pi =3.14;using SI = Sales_item;SI item; //等价于 Sales_item item; 特别的是，当我们用类型别名指代复合类型或常量时，就会有一些地方要注意。 typedef char *pstring;const pstring cstr = 0;const pstring *ps;我们经常喜欢将原来的定义代回代码中进行解释，就如第二行代码可以解释为：const char *cstr = 0//这是错误的解释！！！注意！这个解释是错误的。这种含义是声明了一个指向常量的指针，即常量指针。而原来代码的定义应该是声明一个指向char的指针常量。或者可以用下面的代码进行解释： typedef char* pstring;const pstring cstr = 0;const char* cstr1 = 0;char a = '1';char b = '2';cstr = &amp;a;//报错 因为cstr是一个指针常量cstr1 = &amp;a;//正确 因为cstr1是一个常量指针 13.auto类型说明符和decltype指示符auto我们常常用一个表达式的值去初始化变量，如int a = b+c;，但有时候我们并不清楚应该定义a的数据类型，这时候我们可以让编译器通过初始值来推算变量的类型。auto item = val1 + val2;auto会自动调节使其更符合初始化规则。比如说：(1)auto引用时，会自动转化为引用对象的类型。 int i =0;&amp;r = i;auto a = &amp;r;//此时a是int型(2)auto一般会忽略掉顶层const，保留底层const。 const int ci = i ; &amp;cr = ci;auto b = ci;//b = intauto c = cr;//c = intauto d = &amp;i;//d = int*auto e = &amp;ci;// e = const int*如果需要保存顶层const，则需要const auto ...decltype引出原因：auto用一个表达式初始化了一个变量，但有时候我们想要定义一个变量，但不初始化它，怎么办？C++给我们提供了decltype说明符。它的作用是返回操作数的数据类型，编译器仅仅靠表分析表达式而得出它的类型而不具体去计算表达式的值。decltype(f()) sum = y;这句话中，编译器不实际调用f，而仅仅靠f的返回值来分析数据类型。(1)decltype使用变量：decltype括号内是变量的话，它处理顶层const和引用的方式与auto不同，它直接返回变量的类型。 const int ci = 0,&amp;cj = ci;decltype(ci) x = 0; // x的类型是const intdecltype(cj) y = x; // y的类型是const int&amp;，并将y绑定到x上decltype(cj) z; // 错误，引用必须初始化引用在任何情况下，都作为对象的同义词出现，只有在decltype中例外，它直接返回引用的数据类型。(2)decltype使用表达式(则返回表达式结果的数据类型): int i = 42,*p = &amp;i,&amp;r = i;decltype(r+0) b; // 正确,r+0返回int，因此b是一个未初始化的intdecltype(*p) c;//错误，因为指针解引用返回的数据类型是int&amp;decltype((i)) d;//错误，因为((i))返回的是int&amp; 以上例子中，需要注意的有：指针解引用后返回的是一个引用类型，必须初始化；decltype((variable))的结果永远是引用。","link":"/2022/08/01/%5BC++%20Primer%5D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"title":"【博客搭建】 如何搭建属于自己的博客","text":"因本人电脑较多，安装博客环境需要重复几次，在此记录下搭建博客的过程，用以自己复习避免采坑。 环境安装准备1.Node.js首先打开Node.js的官方网址 选择左边的LTS，然后一路next即可安装完成。然后测试Node是否安装成功，Win+R,打开cmd后输入node -v，npm -v,看是否返回版本号。 2.Git打开Git的官方网址,选择windows下载即可。安装Git时：选择安装目录后选择安装组件，选择依据自己选择。注：图片出处然后一路next即可。 3.搭建hexoWin+R，打开cmd后输入npm install -g cnpm --registry=https://registry.npm.taobao.org，选择淘宝的镜像源，提高下载速度。cnpm install -g hexo-cli，开始安装hexo。刚开始，cmd会定位在c盘中，如果我们想要将hexo中的文件放在其他盘(D盘)就需要定位到其他盘中，输入：D:,然后输入：mkdir D:\\blog，创建一个名为blog的空文件夹。 然后输入：cd: D:\\blog将位置定在blog文件中，输入hexo init初始化hexo。 输入：hexo s，来创建我们的博客环境，此时在浏览器中输入:localhost:4000就可以进入我们的hexo中了。 4.部署博客在github上 打开我们自己的github，然后右上角选择New repository，创建新的子仓库。 部署个人博客的时候命名必须与github账户原名符合，如我的是ginmanzzz，那就要输入ginmanzzz.github.io 然后继续在cmd中输入：npm install hexo-deployer-git --save来安装hexo的安装插件。 安装完成后我们自己手动打开blog的目录，找到其中的config.yml并用vscode打开。在文件的结尾更改为如下方式： 注意冒号后面有空格，不能缺少。 然后输入git config --global user.email &quot;和git config --global user.name &quot;xxx&quot;，其中xxx分别是你的github的email和name。 最后输入hexo d将现在的文件推送上去，这样博客系统就部署好了。","link":"/2022/07/31/my-First-Blog/"}],"tags":[],"categories":[],"pages":[]}